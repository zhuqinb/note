# 基本知识

## express方法和中间件配置

### json()
将请求的参数进行`json`化，并放置`req.body`对象中

`express.json([options])`

```js
const express = require('express')
const app = express()
app.use(express.json())
```

### static()
对于静态资源的配置，如果不配置这个，静态资源将访问不到

`express.static(dir, [options])`

```js
app.use(express.static('public'), {
	setHeaders(res, path, stat) {
		res.set('x-timestamp', Date.now())
	}
})
```

### Router()
创建新新路由

`const router = express.Router([options])`

```js
const router = express.Router()
router.route('/:id')
.get((req, res, next) => {
	req.json({})
})
.put((req, res, next) => {
	req.json({})
})
.delete((req, res, next) => {
	req.json({})
})
```

### urlencoded()

将请求的正文进行解析，并放置`req.body`对象中，只支持`utf-8`，且自动进行`gzip`和`deflate`编码

`express.urlencoded([options])`

```js
app.use(express.urlencoded())
```

## app

### app.locals 

可读写属性，设置和返回整个应用的全局变量

### app.mountpath

包含一个或多个安装了子应用程序的路径模式
```js
const express = require('express')
const parent = express()  //父应用
const child1 = express()  //子应用
const child2 = express()  //子应用

child1.get('/', (req,res) => {
	console.log(child1.mountpath) //['/child1', '/child2']
})
child2.get('/', (req,res) => {})

parent.use(['/child1', '/child2'], child1) // 子应用挂载到了父应用
```

### app.on('mount', cb(parent))

当子应用挂载到父应用上的时候，会触发回调

```js
//... 接着上面的例子
parent.use('/child1', child1) // 子应用挂载到了父应用
child1.on('mount', parent => {
	console.log('挂载成功!')
	console.log(parent) // 引用的父应用
})
```

### app.all(url, [cb...])

这个可以用作中间件，当作过滤器使用;可以处理所有的路径；拦截所有，只有某个满足的条件放行，不满足拒绝;可以放置多个回调

记得写在其他匹配路径的前面

```js
app.all('*', filter1, filter2)
function filter1(req, res, next) {
	if(true){
		next()
	}
}
function filter2(req, res, next) {
	if(true) {
		next()
	}
}
```

### app.delete(path, [cb...])

与app.all()类似，拦截delete请求、或处理

### app.get(path, [cb...])

当只有一个参数的时候，表示返回应用程序的key的值；当有多个参数的时候，作为资源处理

### app.post(path, [cb...])
与app.all()类似，拦截post请求、或处理

### app.put(path, [cb...])
与app.all()类似，拦截put请求、或处理

### app.post(path, [cb...])
与app.all()类似，拦截post请求、或处理

### app.METHOD(path, [cb...])
上面列举的是比较常见的请求，但是其他的请求也是支持的

### app.disable(key)

将应用程序的key设置为false，与app.set(key,false)相同

### app.enable(key)

将应用程序的key设置为true，与app.set(key,true)相同

### app.disabled(key)

对key的boolean取反

### app.enabled(key)

返回key的boolean值

### app.engine('viewName', cb)

```js
app.engine('pug', require('pug')._express)
app.engine('html', require('ejs').renderFile)
```
注册视图模板引擎

```js
// 设置ejs为默认视图引擎
app.set('view engine', 'ejs')

// 设置html为默认视图引擎  先注册后设置
app.engine('html', require('ejs').renderFile)
app.set('view engine', 'html')
```

### app.param()
拦截请求中的动态参数

```js
app.get('/user/:id', function(req, res) => {

})

// 这里的id就是上面get中路径的id，这个回调在上面get之前执行
app.param('id', function(req, res, next, id) => {
	next()
})
```
### app.path()
返回应用程序的规范路径，一个字符串

### app.render()
渲染视图

### app.listen([port, host, backlog], [cb])
用于监听端口
```js
const app = require('express')()
app.listen(3000, function(err) => {
	if(err) console.log(err)
	else console.log('success listening on port 3000!')
})
```
### app.route()

```js
const app = express()

app.route('/user/:id')
  .all((req, res, next) => {

  })
  .get((req, res, next) => {

  })
  .port((req, res, next) => {

  })
```
### app.use(path, [cb...])
指定中间件的函数
```js
app.use('static', express.static(path.resolve('./public')))
```

### app.set()
应用程序的设置

## req

### req.app
应用程序app的引用

### req.baseUrl
挂载路径，类是app.mountpath，除了app.mountpath返回匹配的路径模式。

### req.hostname
主机名
### req.ip
请求IP地址
### req.ips
### req.originalUrl
保留着原始请求url，是req.baseUrl和req.path的组合

```js
app.use('/admin', function (req, res, next) { // GET 'http://www.example.com/admin/new'
  console.dir(req.originalUrl) // '/admin/new'
  console.dir(req.baseUrl) // '/admin'
  console.dir(req.path) // '/new'
  next()
})
```

### req.fresh
指示请求是否"[缓存](https://github.com/jshttp/fresh)"。它是相反的req.stale。

如果cache-control请求标头没有no-cache指令并且满足以下任何条件，则为true：

的if-modified-since请求报头中指定和last-modified请求头是等于或早于modified响应头。
的if-none-match请求头是`*`。
if-none-match解析为其指令后，请求标头与etag响应标头不匹配。

### req.stale
与`req.fresh`相反

### req.path
包含请求URL的路径部分
### req.method
请求的方法
### req.protocol
协议
### req.body
当使用中间件 express.json() 或 express.urlencoded()时，将请求正文填充到body中

```js
const app = require('express')()
app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded
app.port('/user', function(req, res, next) => {
	res.json(req.body)
})
```
### req.cookies
当使用[cookie.parser]('https://github.com/expressjs/cookie-parser')中间件时，此属性包含请求中的cookie对象

```js
var cookieParser = require('cookie-parser')
app.use(cookieParser())
// Cookie: name:tj
app.get('/user', (req, res, next) => {
	console.log(req.cookies.name)
})
```

如果cookie已签名，则必须使用req.signedCookies。

### req.query
保留这查询参数的对象
```js
// /search?a=1&b=2
console.log(req.query.a) //1
```
### req.params
此属性是一个对象，包含映射到命名路由"parameters"的属性。例如，如果您有路径/user/:name，获取的是name值
```js
// localhost:3000/user/xiaoming
app.get('/user/:name', (req,res) => {
	console.log(req.params.name) // xiaoming
})
```

如果路径是通过正则匹配的，这里的params是一个数组

### req.route
包含当前匹配的路由信息

### req.secure
如果建立了TLS连接，返回true
```js
console.log(req.protocol === 'https') // true
```
### req.signedCookies
使用cookie-parser中间件时，此属性包含请求发送的已签名cookie，未签名且可以使用。签名的cookie位于不同的对象中以显示开发者的意图; 否则，可能会对req.cookie值（易于欺骗）进行恶意攻击 。请注意，签署cookie不会使其“隐藏”或加密; 但只是防止篡改（因为用于签名的秘密是私有的）。

如果未发送已签名的cookie，则该属性默认为{}。

```js
// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => 'tobi'
```

### req.subdomails
获取域名中的一个子域
```js
// Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ['ferrets', 'tobi']
```
application属性subdomain offset（默认为2）用于确定子域段的开头。要更改此行为，请使用app.set更改其值。

### req.xhr
一个布尔属性，true如果请求的X-Requested-With头字段是“XMLHttpRequest”，则表示该请求是由客户端库（如jQuery）发出的。

## res

## router