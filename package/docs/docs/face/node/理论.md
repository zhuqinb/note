# JavaScript

## CPU、进程、线程之间的关系

-   进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
-   线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
-   不同进程之间也可以通信，不过代价较大
-   单线程与多线程，都是指在一个进程内的单和多

对于浏览器

-   浏览器是多进程的
-   每一个 Tab 页，就是一个独立的进程

## 浏览器包含了哪些进程

-   主进程

    -   协调控制其他子进程（创建、销毁）
    -   浏览器界面显示，用户交互，前进、后退、收藏
    -   将渲染进程得到的内存中的 Bitmap，绘制到用户界面上
    -   处理不可见操作，网络请求，文件访问等

-   第三方插件进程

    -   每种类型的插件对应一个进程，仅当使用该插件时才创建

-   GPU 进程

    -   用于 3D 绘制等

-   渲染进程，就是我们说的浏览器内核

    -   负责页面渲染，脚本执行，事件处理等
    -   每个 tab 页一个渲染进程

对于前端操作最重要的是渲染进程,也就是浏览器内核

## 浏览器内核（渲染进程）

对于渲染进程来说，它是多线程的

-   GUI 渲染线程

    -   负责渲染页面，布局和绘制
    -   页面需要重绘和回流时，该线程就会执行
    -   与 js 引擎线程互斥，防止渲染结果不可预期

*   JS 引擎线程

    -   负责处理解析和执行 javascript 脚本程序
    -   只有一个 JS 引擎线程（单线程）
    -   与 GUI 渲染线程互斥，防止渲染结果不可预期

-   事件触发线程

    -   用来控制事件循环（鼠标点击、setTimeout、ajax 等）
    -   当事件满足触发条件时，将事件放入到 JS 引擎所在的执行队列中

*   定时触发器线程

    -   setInterval 与 setTimeout 所在的线程
    -   定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的
    -   计时完毕后，通知事件触发线程

异步 http 请求线程

    - 浏览器有一个单独的线程用于处理AJAX请求
    - 当请求完成时，若有回调函数，通知事件触发线程

## event loop

首先，js 是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应 DOM 的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被 push 进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步 HTTP 请求线程满足特定条件下的回调函数 push 到事件队列中，等待 js 引擎空闲的时候去执行，当然 js 引擎执行过程中有优先级之分，首先 js 引擎在一次事件循环中，会先执行 js 线程的主任务，然后会去查找是否有微任务 microtask（promise），如果有那就优先执行微任务，如果没有，在去查找宏任务 macrotask（setTimeout、setInterval）进行执行。

## webpack 优化

[插件列表](https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000016816813)

### 构建优化

1、减少编译体积 ContextReplacementPugin、IgnorePlugin、babel-plugin-import、babel-plugin-transform-runtime。

2、并行编译 happypack、thread-loader、uglifyjsWebpackPlugin 开启并行

3、缓存 cache-loader、hard-source-webpack-plugin、uglifyjsWebpackPlugin 开启缓存、babel-loader 开启缓存

4、预编译 dllWebpackPlugin && DllReferencePlugin、auto-dll-webapck-plugin

### 性能优化

1、减少编译体积 Tree-shaking、Scope Hositing。

2、hash 缓存 webpack-md5-plugin

3、拆包 splitChunksPlugin、import()、require.ensure

## es6 class 和 es5 类区别

## 从输入 URL 到看到页面发生的全过程，越详细越好。

1. 首先浏览器主进程接管，开了一个下载线程。
2. 然后进行 HTTP 请求（DNS 查询、IP 寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。
3. 将下载完的内容转交给 Renderer 进程管理。
4. Renderer 进程开始解析 css rule tree 和 dom tree，这两个过程是并行的，所以一般我会把 link 标签放在页面顶部。
5. 解析绘制过程中，当浏览器遇到 link 标签或者 script、img 等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。
6. css rule tree 和 dom tree 生成完了之后，开始合成 render tree，这个时候浏览器会进行 layout，开始计算每一个节点的位置，然后进行绘制。
7. 绘制结束后，关闭 TCP 连接，过程有四次挥手。

## CSS 和 JS 的位置会影响页面效率，为什么?

css 在加载过程中不会影响到 DOM 树的生成，但是会影响到 Render 树的生成，进而影响到 layout，所以一般来说，style 的 link 标签需要尽量放在 head 里面，因为在解析 DOM 树的时候是自上而下的，而 css 样式又是通过异步加载的，这样的话，解析 DOM 树下的 body 节点和加载 css 样式能尽可能的并行，加快 Render 树的生成的速度。

js 脚本应该放在底部，原因在于 js 线程与 GUI 渲染线程是互斥的关系，如果 js 放在首部，当下载执行 js 的时候，会影响渲染行程绘制页面，js 的作用主要是处理交互，而交互必须得先让页面呈现才能进行，所以为了保证用户体验，尽量让页面先绘制出来。

## 继承

## 浏览器的缓存机制

### 浏览器缓存机制有两种，一种为强缓存，一种为协商缓存。

对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。

对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存。

### 强缓存方案

Exprires：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。Exprires 的缺陷是必须保证服务端时间和客户端时间严格同步。

Cache-control：max-age，表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，

### 协商缓存方案

If-None-Match/ETag：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回 If-None-Match 标识是否表示匹配。

Last-modified/If-Modified-Since：第一次请求的时候服务端返回 Last-modified 表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头 If-Modified-Since，表示资源上次的修改时间，服务端拿到这两个字段进行对比。

## ETag 是这个字符串是怎么生成的？

通常，使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号

## svg 和 canvas 各自的优缺点

### 共同点：都是有效的图形工具，对于数据较小的情况下，都很又高的性能，它们都使用 JavaScript 和 HTML；它们都遵守万维网联合会 (W3C) 标准。

### svg 优点：

矢量图，不依赖于像素，无限放大后不会失真。

以 dom 的形式表示，事件绑定由浏览器直接分发到节点上。

### svg 缺点：

dom 形式，涉及到动画时候需要更新 dom，性能较低。

### canvas 优点：

定制型更强，可以绘制绘制自己想要的东西。
非 dom 结构形式，用 JavaScript 进行绘制，涉及到动画性能较高。

### canvas 缺点：

事件分发由 canvas 处理，绘制的内容的事件需要自己做处理。
依赖于像素，无法高效保真，画布较大时候性能较低。

## 性能优化

浏览器解析->查询缓存->dns 查询->建立链接->服务器处理请求->服务器发送响应->客户端收到页面->解析 HTML->构建渲染树->开始显示内容(白屏时间)->首屏内容加载完成(首屏时间)->用户可交互(DOMContentLoaded)->加载完成(load)

时间监控 performanceTiming,可以获取到很多页面加载相关的数据。 比较常用的有

```js
DNS 解析时间： domainLookupEnd - domainLookupStart
TCP 建立连接时间： connectEnd - connectStart
白屏时间： responseStart - navigationStart
dom 渲染完成时间： domContentLoadedEventEnd - navigationStart
页面 onload 时间： loadEventEnd - navigationStart
```

如果不使用该 API，可以以服务器渲染返回的时间，或是 SPA 路由跳转离开的时间为起点，domContentLoaded，load 等事件为结束点进行记录。或是直接上 google analytics。方法很多，就不细说了。

### 服务器优化要点

后端部分可以对缓存，dns 查询时间，链接时间，处理请求时间，响应时间等进行优化。
缓存就不细说了。
dns 查询时间可以使用 httpdns 或是 dns 预加载，域名收敛等手段优化。我还写了篇介绍 DNS 和 CDN 的文章

建立连接的重点是长连接和链接复用，keep-alive，long-polling，http-straming，websocket 或是自己写过别的协议，更好的是直接上 http2。为了优化链接的环节，前端这里还需要对资源使用 cdn，雪碧图，代码合并等手段。

服务器处理请求这里可以优化的点也不少，值得注意的就是移动端访问 PC 端页面需要跳转到移动端页面时，要再服务器端使用 302 跳转，不要在前端进行跳转。还有就是启用 hsts，要求浏览器在之后的访问使用 https，减少无谓的 http 跳转 https，同时还可以防止 ssl 剥离攻击，提升安全性。

服务器发送响应环节，可以使用 Transfer-Encoding=chunked，多次返回响应，具体操作查询 bigpipe。还有就是减小 cookie 的体积等等。

### 前端部分优化要点

前端部分可以对白屏时间，首屏事件，可交换时间，加载完成时间进行优化。

# NodeJs

## http 和 https

## 进程

## 流(stream)和缓冲(buffer)

## node 时间循环

# CSS 和 HTML

## BFC

块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

IE 下为 Layout，可通过 zoom:1 触发

触发条件:

-   根元素
-   position: absolute/fixed
-   display: inline-block / table
-   float 元素
-   ovevflow !== visible

规则:

-   属于同一个 BFC 的两个相邻 Box 垂直排列
-   属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
-   BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)
-   BFC 的区域不会与 float 的元素区域重叠
-   计算 BFC 的高度时，浮动子元素也参与计算
-   文字层不会被浮动层覆盖，环绕于周围

应用:

-   阻止 margin 重叠
-   可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)
-   自适应两栏布局
-   可以阻止元素被浮动元素覆盖

## 居中布局

-   水平居中

    -   行内元素: text-align: center
    -   块级元素: margin: 0 auto
    -   absolute + transform
    -   flex + justify-content: center

-   垂直居中

    -   line-height: height
    -   absolute + transform
    -   flex + align-items: center
    -   table

-   水平垂直居中

    -   absolute + transform
    -   flex + justify-content + align-items

## 选择器优先级

-   !important > 行内样式 > #id > .class > tag > `*` > 继承 > 默认
-   选择器 从右到左 解析

## 去除浮动影响,防止父级高度塌陷

-   通过增加尾元素清除浮动
    -   :after / <br> :clear: both
-   创建父级 BFC
-   父级设置高度

## css 动画

-   transition: 过渡动画

    -   transition-property: 属性
    -   transition-duration: 间隔
    -   transition-timing-function: 曲线
    -   transition-delay: 延迟
    -   常用钩子: transitionend

-   animation / keyframes

    -   animation-name: 动画名称，对应@keyframes
    -   animation-duration: 间隔
    -   animation-timing-function: 曲线
    -   animation-delay: 延迟
    -   animation-iteration-count: 次数
        -   infinite: 循环动画
    -   animation-direction: 方向

        -   alternate: 反向播放

    -   animation-fill-mode: 静止模式

        -   forwards: 停止时，保留最后一帧
        -   backwards: 停止时，回到第一帧
        -   both: 同时运用 forwards / backwards

    -   常用钩子: animationend

-   动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现
    -   translate
    -   scale
    -   rotate
    -   skew
    -   opacity
    -   color

##
