(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{479:function(s,t,a){"use strict";a.r(t);var e=a(0),r=Object(e.a)({},function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"es6-总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-总结","aria-hidden":"true"}},[s._v("#")]),s._v(" es6 总结")]),s._v(" "),a("h2",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化","aria-hidden":"true"}},[s._v("#")]),s._v(" 模块化")]),s._v(" "),a("p",[s._v("es6 之前,社区对于模块化解决方式主要是 CommonJS 和 AMD,而 es6 在语言层面实现了模块化功能,完全可以取代 CommonJS 和 AMD 规范,成为浏览器和服务器通用的模块解决方案")]),s._v(" "),a("h3",{attrs:{id:"es6-模块还有以下好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块还有以下好处","aria-hidden":"true"}},[s._v("#")]),s._v(" es6 模块还有以下好处.")]),s._v(" "),a("ol",[a("li",[s._v("不在需要 UMD 模块化格式")]),s._v(" "),a("li",[s._v("将来浏览器新的 api 就能用模块格式提供,不必做成全局或 "),a("code",[s._v("navigator")]),s._v(" 对象")]),s._v(" "),a("li",[s._v("不在需要对象作为命名空间(比如 Math 对象)")])]),s._v(" "),a("p",[s._v("CommonJS 和 AMD 只能在运行时确定这些东西")]),s._v(" "),a("h3",{attrs:{id:"es6-模块化特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块化特点","aria-hidden":"true"}},[s._v("#")]),s._v(" es6 模块化特点")]),s._v(" "),a("ol",[a("li",[s._v("静态导入(只加载需要导入的模块,其他的不加载),或者称为 编译时加载")]),s._v(" "),a("li",[s._v("单利模式")]),s._v(" "),a("li",[s._v("变量提升")]),s._v(" "),a("li",[s._v("自动严格模式")]),s._v(" "),a("li",[s._v("export 与对应的值是动态绑定,可以取到模块内部实时的值")]),s._v(" "),a("li",[s._v("不要放到块级作用域下(会提示错误),也不要使用表达式")]),s._v(" "),a("li",[s._v("导出的值是只读的;但是导出的对象还是引用类型,所以还是可以修改,但是不建议这么做")]),s._v(" "),a("li",[s._v("模块整体加载("),a("code",[s._v("*")]),s._v(")指定的对象,不能修改这个对象")])]),s._v(" "),a("h3",{attrs:{id:"export-与-import-复合写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#export-与-import-复合写法","aria-hidden":"true"}},[s._v("#")]),s._v(" export 与 import 复合写法")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" bar "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'my_module'")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"import-提案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import-提案","aria-hidden":"true"}},[s._v("#")]),s._v(" import() 提案")]),s._v(" "),a("p",[s._v("如果 import 命令取代 require 方法,就会形成一个障碍,因为 require 是运行时加载,import 不能取代 require 的动态加载功能,所以加入了 "),a("code",[s._v("import(moduleUrl)")])]),s._v(" "),a("p",[s._v("import 返回一个 promise, 并且值可以进行解构")]),s._v(" "),a("ol",[a("li",[s._v("import()可以用在任何地方,不仅仅是模块,非模块脚本也是可以,是运行时执行.")]),s._v(" "),a("li",[s._v("import()函数与所加载的模块没有静态连接关系,这点也是与 import 语法不相同.")]),s._v(" "),a("li",[s._v("import()类似 Node 的 require 方法,区别主要是前者是异步加载,后者是同步加载.")])]),s._v(" "),a("h3",{attrs:{id:"模块在浏览器中的加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块在浏览器中的加载","aria-hidden":"true"}},[s._v("#")]),s._v(" 模块在浏览器中的加载")]),s._v(" "),a("p",[s._v("默认情况下,浏览器是同步加载 js 脚本,即渲染引擎遇到 script 标签就会停下来,等到执行完脚本,再继续向下渲染.如果是外部脚本,还必须加入脚本下载的时间")]),s._v(" "),a("p",[s._v("如果脚本体积很大,容易造成不好的体验")]),s._v(" "),a("p",[a("code",[s._v("defer")]),s._v(" 和 "),a("code",[s._v("async")]),s._v(" 区别: 前者页面渲染完在执行;后者下载完就执行")]),s._v(" "),a("p",[s._v("浏览器加载 es6 模块")]),s._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("script")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[s._v("type")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')]),s._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')])]),s._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[s._v("src")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')]),s._v("./foo.js"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),a("span",{pre:!0,attrs:{class:"token script"}}),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("script")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("加载 es6 模块会默认打开 defer 属性;也可以手动将 async 属性打开")]),s._v(" "),a("h3",{attrs:{id:"commonjs-模块化特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-模块化特点","aria-hidden":"true"}},[s._v("#")]),s._v(" commonJS 模块化特点")]),s._v(" "),a("ol",[a("li",[s._v("动态导入")]),s._v(" "),a("li",[s._v("值缓存, 不存在动态更新")]),s._v(" "),a("li",[s._v("模块输出的是一个值的拷贝")]),s._v(" "),a("li",[s._v("模块是运行时加载")])]),s._v(" "),a("h3",{attrs:{id:"require-重复引入问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#require-重复引入问题","aria-hidden":"true"}},[s._v("#")]),s._v(" require 重复引入问题")]),s._v(" "),a("p",[s._v("模块化被加载一次之后,就会在缓存中维持一个副本,如果遇到重复加载的模块会直接提取缓存中的副本,也就是说在任何时候每个模块都只在缓存中有一个实例.")]),s._v(" "),a("p",[s._v("但是这种缓存是经过文件路径定位的;即使两个完全相同的文件,但是位于不同的路径,会在缓存中维持两份")]),s._v(" "),a("h3",{attrs:{id:"require-加载模块时是同步的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#require-加载模块时是同步的","aria-hidden":"true"}},[s._v("#")]),s._v(" require 加载模块时是同步的")]),s._v(" "),a("p",[s._v("node 在 require 的时候回自动缓存已经加载的模块,再加上都是本地文件,产生的 io 开销几乎可以忽略")]),s._v(" "),a("h3",{attrs:{id:"exports-与-module-exports-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exports-与-module-exports-区别","aria-hidden":"true"}},[s._v("#")]),s._v(" exports 与 module.exports 区别")]),s._v(" "),a("p",[s._v("在一个 node 执行一个文件时，会给这个文件内生成一个 exports 和 module 对象， 而 module 又有一个 exports 属性。他们之间的关系如下图，都指向一块{}内存区域。")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("用一张图表示其关系就是")]),s._v(" "),a("img",{attrs:{src:s.$withBase("/images/face/es6-01.webp"),alt:"foo"}}),s._v(" "),a("h3",{attrs:{id:"代码说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码说明","aria-hidden":"true"}},[s._v("#")]),s._v(" 代码说明")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// koala.js")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'程序员成长指北'")]),s._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("exports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" exports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// {} {}")]),s._v("\nexports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'程序员成长指南'")]),s._v("\nexports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'指向其他内存区'")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// test.js")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'/koala'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// {a: '程序员成长指南'}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("看上面代码的打印结果，应该能得到这样的结论：")]),s._v(" "),a("p",[s._v("require 导出的是内容 module.exports 指向的内存块内容,并不是 exports 的.简而言之，区分他们之间的区别就是 exports 只是 module.exports 的引用，辅助后者添加内容用的。用内存指向的方式更好理解。")]),s._v(" "),a("h3",{attrs:{id:"常见写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见写法","aria-hidden":"true"}},[s._v("#")]),s._v(" 常见写法:")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" somethings\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 等价于")]),s._v("\nmodule"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" somethings\nexports "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("exports\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("原理很简单，即 module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports 即可。")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5d5639c7e51d453b5c1218b4?utm_source=gold_browser_extension",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考"),a("OutboundLink")],1)])])},[],!1,null,null,null);t.default=r.exports}}]);